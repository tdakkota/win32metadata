// Code generated by mk_from_row.go, DO NOT EDIT.
package types

import (
	"fmt"

	"github.com/tdakkota/win32metadata/md"
)

// FromRow creates Assembly from given Row.
func (f *Assembly) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field HashAlgId: %w", err)
		}
		f.HashAlgId = AssemblyHashAlgorithm(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Version: %w", err)
		}
		f.Version = uint64(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = AssemblyFlags(v)
	}
	{
		v, err := r.Blob(3)
		if err != nil {
			return fmt.Errorf("decode field PublicKey: %w", err)
		}
		f.PublicKey = Blob(v)
	}
	{
		v, err := r.String(4)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.String(5)
		if err != nil {
			return fmt.Errorf("decode field Culture: %w", err)
		}
		f.Culture = string(v)
	}
	return nil
}

// FromRow creates AssemblyOS from given Row.
func (f *AssemblyOS) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field OSPlatformID: %w", err)
		}
		f.OSPlatformID = uint32(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field OSMajorVersion: %w", err)
		}
		f.OSMajorVersion = uint32(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field OSMinorVersion: %w", err)
		}
		f.OSMinorVersion = uint32(v)
	}
	return nil
}

// FromRow creates AssemblyProcessor from given Row.
func (f *AssemblyProcessor) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Processor: %w", err)
		}
		f.Processor = uint32(v)
	}
	return nil
}

// FromRow creates AssemblyRefOS from given Row.
func (f *AssemblyRefOS) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field OSPlatformID: %w", err)
		}
		f.OSPlatformID = uint32(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field OSMajorVersion: %w", err)
		}
		f.OSMajorVersion = uint32(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field OSMinorVersion: %w", err)
		}
		f.OSMinorVersion = uint32(v)
	}
	{
		v, err := r.Uint64(3)
		if err != nil {
			return fmt.Errorf("decode field AssemblyRef: %w", err)
		}
		f.AssemblyRef = Index(v)
	}
	return nil
}

// ResolveAssemblyRef resolves AssemblyRef index using given Context.
func (f *AssemblyRefOS) ResolveAssemblyRef(c *Context) (AssemblyRef, error) {
	table := c.Table(md.AssemblyRef)
	var t AssemblyRef
	if err := t.FromRow(table.Row(uint32(f.AssemblyRef) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates AssemblyRefProcessor from given Row.
func (f *AssemblyRefProcessor) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Processor: %w", err)
		}
		f.Processor = uint32(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field AssemblyRef: %w", err)
		}
		f.AssemblyRef = Index(v)
	}
	return nil
}

// ResolveAssemblyRef resolves AssemblyRef index using given Context.
func (f *AssemblyRefProcessor) ResolveAssemblyRef(c *Context) (AssemblyRef, error) {
	table := c.Table(md.AssemblyRef)
	var t AssemblyRef
	if err := t.FromRow(table.Row(uint32(f.AssemblyRef) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates AssemblyRef from given Row.
func (f *AssemblyRef) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Version: %w", err)
		}
		f.Version = uint64(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = AssemblyFlags(v)
	}
	{
		v, err := r.Blob(2)
		if err != nil {
			return fmt.Errorf("decode field PublicKeyOrToken: %w", err)
		}
		f.PublicKeyOrToken = Blob(v)
	}
	{
		v, err := r.String(3)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.String(4)
		if err != nil {
			return fmt.Errorf("decode field Culture: %w", err)
		}
		f.Culture = string(v)
	}
	{
		v, err := r.Blob(5)
		if err != nil {
			return fmt.Errorf("decode field HashValue: %w", err)
		}
		f.HashValue = Blob(v)
	}
	return nil
}

// FromRow creates ClassLayout from given Row.
func (f *ClassLayout) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field PackingSize: %w", err)
		}
		f.PackingSize = uint16(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field ClassSize: %w", err)
		}
		f.ClassSize = uint32(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field Parent: %w", err)
		}
		f.Parent = Index(v)
	}
	return nil
}

// ResolveParent resolves Parent index using given Context.
func (f *ClassLayout) ResolveParent(c *Context) (TypeDef, error) {
	table := c.Table(md.TypeDef)
	var t TypeDef
	if err := t.FromRow(table.Row(uint32(f.Parent) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates Constant from given Row.
func (f *Constant) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Type: %w", err)
		}
		f.Type = ElementTypeKind(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Parent: %w", err)
		}
		f.Parent = HasConstant(v)
	}
	{
		v, err := r.Blob(2)
		if err != nil {
			return fmt.Errorf("decode field Value: %w", err)
		}
		f.Value = Blob(v)
	}
	return nil
}

// FromRow creates CustomAttribute from given Row.
func (f *CustomAttribute) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Parent: %w", err)
		}
		f.Parent = HasCustomAttribute(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Type: %w", err)
		}
		f.Type = CustomAttributeType(v)
	}
	{
		v, err := r.Blob(2)
		if err != nil {
			return fmt.Errorf("decode field Value: %w", err)
		}
		f.Value = Blob(v)
	}
	return nil
}

// FromRow creates DeclSecurity from given Row.
func (f *DeclSecurity) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Action: %w", err)
		}
		f.Action = uint16(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Parent: %w", err)
		}
		f.Parent = HasDeclSecurity(v)
	}
	{
		v, err := r.Blob(2)
		if err != nil {
			return fmt.Errorf("decode field PermissionSet: %w", err)
		}
		f.PermissionSet = Blob(v)
	}
	return nil
}

// FromRow creates Event from given Row.
func (f *Event) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field EventFlags: %w", err)
		}
		f.EventFlags = EventAttributes(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field EventType: %w", err)
		}
		f.EventType = TypeDefOrRef(v)
	}
	return nil
}

// FromRow creates EventMap from given Row.
func (f *EventMap) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Parent: %w", err)
		}
		f.Parent = Index(v)
	}
	{
		v, err := r.List(1, md.Event)
		if err != nil {
			return fmt.Errorf("decode field EventList: %w", err)
		}
		f.EventList = List(v)
	}
	return nil
}

// ResolveParent resolves Parent index using given Context.
func (f *EventMap) ResolveParent(c *Context) (TypeDef, error) {
	table := c.Table(md.TypeDef)
	var t TypeDef
	if err := t.FromRow(table.Row(uint32(f.Parent) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// ResolveEventList resolves EventList index using given Context.
func (f *EventMap) ResolveEventList(c *Context) ([]Event, error) {
	table := c.Table(md.Event)
	if f.EventList.Empty() {
		return nil, nil
	}

	var (
		t      Event
		result = make([]Event, 0, f.EventList.Size())
	)
	for i := f.EventList.Start(); i < f.EventList.End(); i++ {
		if err := t.FromRow(table.Row(i)); err != nil {
			return result, err
		}
		result = append(result, t)
	}

	return result, nil
}

// FromRow creates ExportedType from given Row.
func (f *ExportedType) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = TypeAttributes(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field TypeDefId: %w", err)
		}
		f.TypeDefId = uint32(v)
	}
	{
		v, err := r.String(2)
		if err != nil {
			return fmt.Errorf("decode field TypeName: %w", err)
		}
		f.TypeName = string(v)
	}
	{
		v, err := r.String(3)
		if err != nil {
			return fmt.Errorf("decode field TypeNamespace: %w", err)
		}
		f.TypeNamespace = string(v)
	}
	{
		v, err := r.Uint64(4)
		if err != nil {
			return fmt.Errorf("decode field Implementation: %w", err)
		}
		f.Implementation = Implementation(v)
	}
	return nil
}

// FromRow creates Field from given Row.
func (f *Field) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = FieldAttributes(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Signature(2)
		if err != nil {
			return fmt.Errorf("decode field Signature: %w", err)
		}
		f.Signature = Signature(v)
	}
	return nil
}

// FromRow creates FieldLayout from given Row.
func (f *FieldLayout) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Offset: %w", err)
		}
		f.Offset = uint32(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Field: %w", err)
		}
		f.Field = Index(v)
	}
	return nil
}

// ResolveField resolves Field index using given Context.
func (f *FieldLayout) ResolveField(c *Context) (Field, error) {
	table := c.Table(md.Field)
	var t Field
	if err := t.FromRow(table.Row(uint32(f.Field) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates FieldMarshal from given Row.
func (f *FieldMarshal) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Parent: %w", err)
		}
		f.Parent = Index(v)
	}
	{
		v, err := r.Blob(1)
		if err != nil {
			return fmt.Errorf("decode field NativeType: %w", err)
		}
		f.NativeType = Blob(v)
	}
	return nil
}

// FromRow creates FieldRVA from given Row.
func (f *FieldRVA) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field RVA: %w", err)
		}
		f.RVA = uint32(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Field: %w", err)
		}
		f.Field = Index(v)
	}
	return nil
}

// ResolveField resolves Field index using given Context.
func (f *FieldRVA) ResolveField(c *Context) (Field, error) {
	table := c.Table(md.Field)
	var t Field
	if err := t.FromRow(table.Row(uint32(f.Field) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates File from given Row.
func (f *File) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = FileAttributes(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Blob(2)
		if err != nil {
			return fmt.Errorf("decode field HashValue: %w", err)
		}
		f.HashValue = Blob(v)
	}
	return nil
}

// FromRow creates GenericParam from given Row.
func (f *GenericParam) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Number: %w", err)
		}
		f.Number = uint16(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = GenericParamAttributes(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field Owner: %w", err)
		}
		f.Owner = TypeOrMethodDef(v)
	}
	{
		v, err := r.String(3)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	return nil
}

// FromRow creates GenericParamConstraint from given Row.
func (f *GenericParamConstraint) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Owner: %w", err)
		}
		f.Owner = Index(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Constraint: %w", err)
		}
		f.Constraint = TypeDefOrRef(v)
	}
	return nil
}

// ResolveOwner resolves Owner index using given Context.
func (f *GenericParamConstraint) ResolveOwner(c *Context) (GenericParam, error) {
	table := c.Table(md.GenericParam)
	var t GenericParam
	if err := t.FromRow(table.Row(uint32(f.Owner) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates ImplMap from given Row.
func (f *ImplMap) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field MappingFlags: %w", err)
		}
		f.MappingFlags = PInvokeAttributes(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field MemberForwarded: %w", err)
		}
		f.MemberForwarded = MemberForwarded(v)
	}
	{
		v, err := r.String(2)
		if err != nil {
			return fmt.Errorf("decode field ImportName: %w", err)
		}
		f.ImportName = string(v)
	}
	{
		v, err := r.Uint64(3)
		if err != nil {
			return fmt.Errorf("decode field ImportScope: %w", err)
		}
		f.ImportScope = Index(v)
	}
	return nil
}

// ResolveImportScope resolves ImportScope index using given Context.
func (f *ImplMap) ResolveImportScope(c *Context) (ModuleRef, error) {
	table := c.Table(md.ModuleRef)
	var t ModuleRef
	if err := t.FromRow(table.Row(uint32(f.ImportScope) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates InterfaceImpl from given Row.
func (f *InterfaceImpl) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Class: %w", err)
		}
		f.Class = Index(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Interface: %w", err)
		}
		f.Interface = TypeDefOrRef(v)
	}
	return nil
}

// ResolveClass resolves Class index using given Context.
func (f *InterfaceImpl) ResolveClass(c *Context) (TypeDef, error) {
	table := c.Table(md.TypeDef)
	var t TypeDef
	if err := t.FromRow(table.Row(uint32(f.Class) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates ManifestResource from given Row.
func (f *ManifestResource) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Offset: %w", err)
		}
		f.Offset = uint32(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = ManifestResourceAttributes(v)
	}
	{
		v, err := r.String(2)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Uint64(3)
		if err != nil {
			return fmt.Errorf("decode field Implementation: %w", err)
		}
		f.Implementation = Implementation(v)
	}
	return nil
}

// FromRow creates MemberRef from given Row.
func (f *MemberRef) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Class: %w", err)
		}
		f.Class = MemberRefParent(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Signature(2)
		if err != nil {
			return fmt.Errorf("decode field Signature: %w", err)
		}
		f.Signature = Signature(v)
	}
	return nil
}

// FromRow creates MethodDef from given Row.
func (f *MethodDef) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field RVA: %w", err)
		}
		f.RVA = uint32(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field ImplFlags: %w", err)
		}
		f.ImplFlags = MethodImplAttributes(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = MethodAttributes(v)
	}
	{
		v, err := r.String(3)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Signature(4)
		if err != nil {
			return fmt.Errorf("decode field Signature: %w", err)
		}
		f.Signature = Signature(v)
	}
	{
		v, err := r.List(5, md.Param)
		if err != nil {
			return fmt.Errorf("decode field ParamList: %w", err)
		}
		f.ParamList = List(v)
	}
	return nil
}

// ResolveParamList resolves ParamList index using given Context.
func (f *MethodDef) ResolveParamList(c *Context) ([]Param, error) {
	table := c.Table(md.Param)
	if f.ParamList.Empty() {
		return nil, nil
	}

	var (
		t      Param
		result = make([]Param, 0, f.ParamList.Size())
	)
	for i := f.ParamList.Start(); i < f.ParamList.End(); i++ {
		if err := t.FromRow(table.Row(i)); err != nil {
			return result, err
		}
		result = append(result, t)
	}

	return result, nil
}

// FromRow creates MethodImpl from given Row.
func (f *MethodImpl) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Class: %w", err)
		}
		f.Class = Index(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field MethodBody: %w", err)
		}
		f.MethodBody = MethodDefOrRef(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field MethodDeclaration: %w", err)
		}
		f.MethodDeclaration = MethodDefOrRef(v)
	}
	return nil
}

// ResolveClass resolves Class index using given Context.
func (f *MethodImpl) ResolveClass(c *Context) (TypeDef, error) {
	table := c.Table(md.TypeDef)
	var t TypeDef
	if err := t.FromRow(table.Row(uint32(f.Class) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates MethodSemantics from given Row.
func (f *MethodSemantics) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Semantics: %w", err)
		}
		f.Semantics = MethodSemanticsAttributes(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Method: %w", err)
		}
		f.Method = Index(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field Association: %w", err)
		}
		f.Association = HasSemantics(v)
	}
	return nil
}

// ResolveMethod resolves Method index using given Context.
func (f *MethodSemantics) ResolveMethod(c *Context) (MethodDef, error) {
	table := c.Table(md.MethodDef)
	var t MethodDef
	if err := t.FromRow(table.Row(uint32(f.Method) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates MethodSpec from given Row.
func (f *MethodSpec) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Method: %w", err)
		}
		f.Method = MethodDefOrRef(v)
	}
	{
		v, err := r.Blob(1)
		if err != nil {
			return fmt.Errorf("decode field Instantiation: %w", err)
		}
		f.Instantiation = Blob(v)
	}
	return nil
}

// FromRow creates Module from given Row.
func (f *Module) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Generation: %w", err)
		}
		f.Generation = uint16(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Uint64(2)
		if err != nil {
			return fmt.Errorf("decode field Mvid: %w", err)
		}
		f.Mvid = GUID(v)
	}
	{
		v, err := r.Uint64(3)
		if err != nil {
			return fmt.Errorf("decode field EncId: %w", err)
		}
		f.EncId = GUID(v)
	}
	{
		v, err := r.Uint64(4)
		if err != nil {
			return fmt.Errorf("decode field EncBaseId: %w", err)
		}
		f.EncBaseId = GUID(v)
	}
	return nil
}

// FromRow creates ModuleRef from given Row.
func (f *ModuleRef) FromRow(r Row) error {
	{
		v, err := r.String(0)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	return nil
}

// FromRow creates NestedClass from given Row.
func (f *NestedClass) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field NestedClass: %w", err)
		}
		f.NestedClass = Index(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field EnclosingClass: %w", err)
		}
		f.EnclosingClass = Index(v)
	}
	return nil
}

// ResolveNestedClass resolves NestedClass index using given Context.
func (f *NestedClass) ResolveNestedClass(c *Context) (TypeDef, error) {
	table := c.Table(md.TypeDef)
	var t TypeDef
	if err := t.FromRow(table.Row(uint32(f.NestedClass) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// ResolveEnclosingClass resolves EnclosingClass index using given Context.
func (f *NestedClass) ResolveEnclosingClass(c *Context) (TypeDef, error) {
	table := c.Table(md.TypeDef)
	var t TypeDef
	if err := t.FromRow(table.Row(uint32(f.EnclosingClass) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// FromRow creates Param from given Row.
func (f *Param) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = ParamAttributes(v)
	}
	{
		v, err := r.Uint64(1)
		if err != nil {
			return fmt.Errorf("decode field Sequence: %w", err)
		}
		f.Sequence = uint16(v)
	}
	{
		v, err := r.String(2)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	return nil
}

// FromRow creates Property from given Row.
func (f *Property) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = PropertyAttributes(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field Name: %w", err)
		}
		f.Name = string(v)
	}
	{
		v, err := r.Signature(2)
		if err != nil {
			return fmt.Errorf("decode field Type: %w", err)
		}
		f.Type = Signature(v)
	}
	return nil
}

// FromRow creates PropertyMap from given Row.
func (f *PropertyMap) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Parent: %w", err)
		}
		f.Parent = Index(v)
	}
	{
		v, err := r.List(1, md.Property)
		if err != nil {
			return fmt.Errorf("decode field PropertyList: %w", err)
		}
		f.PropertyList = List(v)
	}
	return nil
}

// ResolveParent resolves Parent index using given Context.
func (f *PropertyMap) ResolveParent(c *Context) (TypeDef, error) {
	table := c.Table(md.TypeDef)
	var t TypeDef
	if err := t.FromRow(table.Row(uint32(f.Parent) - 1)); err != nil {
		return t, err
	}
	return t, nil
}

// ResolvePropertyList resolves PropertyList index using given Context.
func (f *PropertyMap) ResolvePropertyList(c *Context) ([]Property, error) {
	table := c.Table(md.Property)
	if f.PropertyList.Empty() {
		return nil, nil
	}

	var (
		t      Property
		result = make([]Property, 0, f.PropertyList.Size())
	)
	for i := f.PropertyList.Start(); i < f.PropertyList.End(); i++ {
		if err := t.FromRow(table.Row(i)); err != nil {
			return result, err
		}
		result = append(result, t)
	}

	return result, nil
}

// FromRow creates TypeDef from given Row.
func (f *TypeDef) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field Flags: %w", err)
		}
		f.Flags = TypeAttributes(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field TypeName: %w", err)
		}
		f.TypeName = string(v)
	}
	{
		v, err := r.String(2)
		if err != nil {
			return fmt.Errorf("decode field TypeNamespace: %w", err)
		}
		f.TypeNamespace = string(v)
	}
	{
		v, err := r.Uint64(3)
		if err != nil {
			return fmt.Errorf("decode field Extends: %w", err)
		}
		f.Extends = TypeDefOrRef(v)
	}
	{
		v, err := r.List(4, md.Field)
		if err != nil {
			return fmt.Errorf("decode field FieldList: %w", err)
		}
		f.FieldList = List(v)
	}
	{
		v, err := r.List(5, md.MethodDef)
		if err != nil {
			return fmt.Errorf("decode field MethodList: %w", err)
		}
		f.MethodList = List(v)
	}
	return nil
}

// ResolveFieldList resolves FieldList index using given Context.
func (f *TypeDef) ResolveFieldList(c *Context) ([]Field, error) {
	table := c.Table(md.Field)
	if f.FieldList.Empty() {
		return nil, nil
	}

	var (
		t      Field
		result = make([]Field, 0, f.FieldList.Size())
	)
	for i := f.FieldList.Start(); i < f.FieldList.End(); i++ {
		if err := t.FromRow(table.Row(i)); err != nil {
			return result, err
		}
		result = append(result, t)
	}

	return result, nil
}

// ResolveMethodList resolves MethodList index using given Context.
func (f *TypeDef) ResolveMethodList(c *Context) ([]MethodDef, error) {
	table := c.Table(md.MethodDef)
	if f.MethodList.Empty() {
		return nil, nil
	}

	var (
		t      MethodDef
		result = make([]MethodDef, 0, f.MethodList.Size())
	)
	for i := f.MethodList.Start(); i < f.MethodList.End(); i++ {
		if err := t.FromRow(table.Row(i)); err != nil {
			return result, err
		}
		result = append(result, t)
	}

	return result, nil
}

// FromRow creates TypeRef from given Row.
func (f *TypeRef) FromRow(r Row) error {
	{
		v, err := r.Uint64(0)
		if err != nil {
			return fmt.Errorf("decode field ResolutionScope: %w", err)
		}
		f.ResolutionScope = ResolutionScope(v)
	}
	{
		v, err := r.String(1)
		if err != nil {
			return fmt.Errorf("decode field TypeName: %w", err)
		}
		f.TypeName = string(v)
	}
	{
		v, err := r.String(2)
		if err != nil {
			return fmt.Errorf("decode field TypeNamespace: %w", err)
		}
		f.TypeNamespace = string(v)
	}
	return nil
}

// FromRow creates TypeSpec from given Row.
func (f *TypeSpec) FromRow(r Row) error {
	{
		v, err := r.Signature(0)
		if err != nil {
			return fmt.Errorf("decode field Signature: %w", err)
		}
		f.Signature = Signature(v)
	}
	return nil
}
